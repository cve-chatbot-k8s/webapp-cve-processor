package kafka

import (
	"github.com/confluentinc/confluent-kafka-go/kafka"
	"os"
)

type Service interface {
	ProduceCveRecord(topic string, value []byte, key string, deliveryChan chan kafka.Event) error
}

type Producer struct {
	producer *kafka.Producer
	config   kafka.ConfigMap
}

func NewProducer(config kafka.ConfigMap) (Producer, error) {
	producer, err := kafka.NewProducer(&config)
	if err != nil {
		return Producer{
			producer: nil,
		}, err
	}

	return Producer{
		producer: producer,
	}, nil
}

func CreateConfigMap() kafka.ConfigMap {
	return kafka.ConfigMap{
		"bootstrap.servers":            os.Getenv("BOOTSTRAP_SERVERS"),
		"client.id":                    os.Getenv("CLIENT_ID"),
		"acks":                         os.Getenv("ACKS"),
		"message.max.bytes":            os.Getenv("MESSAGE_MAX_BYTES"),            // 5MB
		"queue.buffering.max.messages": os.Getenv("QUEUE_BUFFERING_MAX_MESSAGES"), // Increase as needed
		//"queue.buffering.max.ms":       "1000",    // 1 second
	}
}

func (p *Producer) ProduceCveRecord(topic string, value []byte, key string, deliveryChan chan kafka.Event) error {
	p.producer.Produce(&kafka.Message{
		TopicPartition: kafka.TopicPartition{Topic: &topic, Partition: kafka.PartitionAny},
		Value:          value,
		Key:            []byte(key),
	}, deliveryChan)

	return nil
}
