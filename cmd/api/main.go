package main

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"runtime"
	"strings"
	"sync"
	"syscall"
	"time"
	"webapp/internal/kafka"
	"webapp/internal/processor"
	"webapp/internal/server"

	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
)

func main() {
	zerolog.TimeFieldFormat = time.RFC3339
	runtime.GOMAXPROCS(runtime.NumCPU())
	fmt.Println("go max procs", runtime.GOMAXPROCS(runtime.NumCPU()))

	var wg sync.WaitGroup
	s := server.NewServer()
	wg.Add(1)
	go func() {
		defer wg.Done()
		if err := s.ListenAndServe(); err != nil {
			log.Error().Err(err).Msg("Failed to start the server")
		}
	}()

	kafkaBootstrapServers := os.Getenv("KAFKA_BOOTSTRAP_SERVERS")
	if kafkaBootstrapServers == "" {
		log.Error().Msg("KAFKA_BOOTSTRAP_SERVERS environment variable is not set")
	}
	brokers := strings.Split(kafkaBootstrapServers, ",")

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	producer1, err := kafka.NewProducer(brokers)
	if err != nil {
		log.Error().Msgf("error creating producer: %v", err)
		return
	}
	log.Print("Producer1 created successfully")

	wg.Add(1) // Add to the wait group for HandleErrors
	go func() {
		defer wg.Done()
		producer1.HandleErrors(ctx)
	}()

	proc := processor.NewProcessor(&producer1)

	// Handle shutdown signals to gracefully shut down the processor
	sigs := make(chan os.Signal, 1)
	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)
	go func() {
		<-sigs
		proc.Shutdown()
		cancel()
	}()

	proc.DownloadCVERecords()
	log.Print("CVE records downloaded successfully")
	log.Print("Starting to read records")
	err = proc.ReadRecords()
	if err != nil {
		log.Error().Msg("error reading records: " + err.Error())
		return
	}

	// Wait for all records to be processed before exiting
	<-proc.Done()
	log.Print("Records read successfully")

	cancel()  // Ensure that the context is cancelled to exit HandleErrors
	wg.Wait() // Wait for HandleErrors to complete

	log.Print("All goroutines completed")
}
