package main

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"runtime"
	"strings"
	"sync"
	"syscall"
	"time"
	"webapp/internal/kafka"
	"webapp/internal/processor"
	"webapp/internal/server"

	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
)

func main() {
	zerolog.TimeFieldFormat = time.RFC3339
	runtime.GOMAXPROCS(runtime.NumCPU())
	fmt.Println("go max procs", runtime.GOMAXPROCS(runtime.NumCPU()))

	var wg sync.WaitGroup
	s := server.NewServer()
	wg.Add(1)
	go func() {
		defer wg.Done()
		if err := s.ListenAndServe(); err != nil {
			log.Error().Err(err).Msg("Failed to start the server")
		}
	}()

	kafkaBootstrapServers := os.Getenv("KAFKA_BOOTSTRAP_SERVERS")
	if kafkaBootstrapServers == "" {
		log.Error().Msg("KAFKA_BOOTSTRAP_SERVERS environment variable is not set")
	}
	brokers := strings.Split(kafkaBootstrapServers, ",")

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	producer1, err := kafka.NewProducer(brokers)
	if err != nil {
		log.Fatal().Msgf("error creating producer: %v", err)
		return
	}
	log.Print("Producer1 created successfully")

	wg.Add(1) // Add to the wait group for HandleErrors
	go func() {
		defer wg.Done()
		producer1.HandleErrors(ctx)
	}()

	proc := processor.NewProcessor(&producer1)

	proc.DownloadCVERecords()
	log.Print("CVE records downloaded successfully")
	log.Print("Starting to read records")
	err = proc.ReadRecords()
	if err != nil {
		log.Error().Msg("error reading records: " + err.Error())
		return
	}

	var duration time.Duration
	if os.Getenv("DELTA_CVE_URL") != "" {
		duration = time.Minute * 2
	} else {
		duration = time.Minute * 10
	}

	timer := time.NewTimer(duration)
	go func() {
		<-timer.C
		log.Print("Timer expired, sending SIGTERM to the application")
		p, err := os.FindProcess(os.Getpid())
		if err != nil {
			log.Error().Msgf("error finding process: %v", err)
			return
		}
		p.Signal(syscall.SIGTERM)
	}()

	// Handle SIGTERM signal
	sigs := make(chan os.Signal, 1)
	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)
	go func() {
		<-sigs
		log.Print("Received shutdown signal, shutting down the application")
		cancel()

		// Define the endpoint for the Istio Envoy sidecar admin interface
		istioEndpoint := "http://localhost:15020/quitquitquit"

		// Create a POST request to shut down Envoy
		req, err := http.NewRequest("POST", istioEndpoint, nil)
		if err != nil {
			log.Error().Err(err).Msg("Error creating request")
		}

		// Send the request using a new client
		client := &http.Client{}
		resp, err := client.Do(req)
		if err != nil {
			log.Error().Err(err).Msg("Error sending request to Envoy:")
		}
		defer resp.Body.Close()
		log.Info().Msgf("Envoy shutdown response status: %s", resp.Status)
		os.Exit(0)
	}()

	// Wait for all records to be processed before exiting
	<-proc.Done()
	log.Print("Records read successfully")

	wg.Wait() // Wait for HandleErrors to complete
	cancel()  // Ensure that the context is cancelled to exit HandleErrors

	log.Print("All goroutines completed")
}
