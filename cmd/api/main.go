package main

import (
	"context"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	_ "net/http/pprof"
	"os"
	"runtime"
	"strings"
	"sync"
	"time"
	"webapp/internal/kafka"
	"webapp/internal/processor"
	"webapp/internal/server"
)

func main() {
	// Use the below goroutine to profile the application
	// go tool pprof http://localhost:6060/debug/pprof/heap
	//go func() {
	//	log.Print(http.ListenAndServe("localhost:6060", nil))
	//}()
	zerolog.TimeFieldFormat = time.RFC3339
	//zerolog.SetGlobalLevel(zerolog.InfoLevel)
	//file, err := os.Create("log.txt")
	//if err != nil {
	//	log.Fatal().Err(err).Msg("Failed to create log file")
	//}
	//defer file.Close()

	// Configure zerolog to write to the file
	//log.Logger = log.Output(zerolog.ConsoleWriter{Out: file, TimeFormat: time.RFC3339})
	runtime.GOMAXPROCS(runtime.NumCPU())

	var wg sync.WaitGroup
	s := server.NewServer()
	wg.Add(1)
	go func() {
		defer wg.Done()
		if err := s.ListenAndServe(); err != nil {
			log.Error().Err(err).Msg("Failed to start the server")
		}
	}()

	kafkaBootstrapServers := os.Getenv("KAFKA_BOOTSTRAP_SERVERS")
	if kafkaBootstrapServers == "" {
		log.Error().Msg("KAFKA_BOOTSTRAP_SERVERS environment variable is not set")
	}
	brokers := strings.Split(kafkaBootstrapServers, ",")

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	producer1, err := kafka.NewProducer(brokers)
	if err != nil {
		log.Error().Msgf("error creating producer: %v", err)
		return
	}
	log.Print("Producer1 created successfully")
	go producer1.HandleErrors(ctx)

	proc := processor.NewProcessor(&producer1)
	proc.DownloadCVERecords()
	log.Print("CVE records downloaded successfully")
	log.Print("Starting read records")
	err = proc.ReadRecords()
	if err != nil {
		log.Error().Msg("error reading records: " + err.Error())
		return
	}

	wg.Wait()
	log.Print("Records read successfully")
}
